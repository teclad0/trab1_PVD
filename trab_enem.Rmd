---
title: "trab1"
output: html_document
date: '2022-04-01'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Descrição do conjunto
i) local onde foi obtido, (iii) contexto do conjunto de dados, (iii) dicionário dos dados
(descrição de cada coluna), e (iv) tipos de dado de cada atributo.
[] TODO

# Inicialização
```{r}
library(tidyverse)

```


# Importação
A ingestão dos dados foi realizada pegando uma porção dos conjuntos de dados pois este é muito grande para ser importado e processado.
```{r}
file <- 'enem/DADOS/MICRODADOS_ENEM_2020.csv'
enem.df <- read_delim(file, n_max = 1000000, delim=";", col_names = TRUE)
```
# Pré-Processamento

## Verificação de possíveis atributos redundantes
Para o calculo de covariancia, é necessário dropar colunas com valores constantes e tratar casos com desvio padrão 0 e com valores NA. 
[]TODO: variaveis nominais

```{r}
enem.df_numeric <- as.data.frame(enem.df %>% select(where(is.numeric), -NU_ANO))

cor_fun<- function(x,y){
  val <- tryCatch(cor(x, y), error = function(e) e, warning = function(w) w)
  if (any(class(val) %in% c("simpleWarning", "warning"))) {
    return(mean(x))
  } else {
    return(val)
  }
}

medidas <- function(vetor1,vetor2){
  corr_medida <- cor_fun(vetor1,vetor2)
  det_medida <- cor_fun(vetor1,vetor2) ^2
  lista_medidas <- list("correlacao"= corr_medida, "determinacao"= det_medida)
  lista_medidas
}

resultado <- tibble(
  colu1= character(),
  colu2= character(),
  r= numeric(),
  R2=numeric()
)

calculo_redundante <- function(dados){
  for (col1 in colnames(dados)) {
    for(col2 in colnames(dados)){
      if (col1 == col2) {
        next
      }
      li_med <- medidas(dados[,col1], dados[,col2])

      #Retornar apenas atributos com valores relevantes
      if(!is.na(li_med$correlacao) & !is.na(li_med$determinacao)){
      if(li_med$correlacao > 0.7 | li_med$correlacao < -0.7 | li_med$determinacao > 0.7){
        resultado <- add_row(resultado, colu1=col1, colu2=col2, r=li_med$correlacao,R2=li_med$determinacao)
        #print(paste(col1, "::", col2))
          #print(paste(li_med))

      }
        }

      }
  }
  resultado<- resultado[!duplicated(apply(resultado,1,function(x) paste(sort(x),collapse=''))),]
   resultado <- resultado %>% arrange(desc(r), desc(R2))
  return(resultado)
  }

resultado <- calculo_redundante(enem.df_numeric)
resultado

```
Através do resultado, é possível observar que os atributos TP_PRESENCA_CH e  TP_PRESENCA_LC, TP_PRESENCA_MT e TP_PRESENCA_CN possuem r e R² iguais a um. Isso significa que todos os valores são exatamente iguais. Essa situação faz sentido pois as provas de linguagens e códigos e ciências humanas, e ciencias da natureza e matemática são realizadas no mesmo dia. Além disso os atributos CO_MUNICIPIO_PROVA e CO_UF_PROVA possuem um valor bem próximo de 1 sendo 0.99 para o r e 0.99 para o R².
Portando, para esses atributos a decisão é remover um de cada par pois seus valores são exatamente iguais ou muito próximos. 
Ainda analisando os coeficientes, é possível entender que 

### Atributos categoricos
```{r}

```






